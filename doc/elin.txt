*elin.txt*            Extensible Lisp Integration for Neovim            *elin*
>
                                 ,dPb,    |
                                 IP"Yb   -*-
                        |        I8 8P gg |
                       -*-       db 8I ""             |
                        |  ,gg,  d8 8" gg  ,gg, ,gg  -*-
                          i8" 8i I8dP  88 ,8PY8YP"g8, |
                          8I ,8I I8P   d8 I8  8I   8i
                        _,Igd8P,,d8b,_,88,dP  8I   "8,
                       888P""Y888P'"Y8P""8P'  8I    "8i
<
                              for Neovim `+v0.8.0`
==============================================================================
About                                                             *elin-about*

Elin enhances neovim with seamless fennel configuration. Just write `.fnl`
files where you would normally write `.lua` or `.vim` files. For more info,
see |elin-config|.

Fennel is a lisp that compiles directly to lua or evaluates fennel using a lua
interpreter. Elin uses neovim's |lua-luajit| to bootstrap fennel on top and
tries to make it as comfortable to use `.fnl` files as it is to use `.lua`
files everywhere.

There are also some nice commands for evaluating fennel in various ways. Check
out |fennel-commands|.
                                                             *elin-fennel-toc*
For your convenience, some reference help documents, with the good graces of
the fennel maintainers, are ported and distributed with this plugin:

  • |fennel-tutorial.txt| • |fennel-reference.txt|   • |fennel-api.txt
  • |fennel-macros.txt|   • |fennel-style.txt|       • |fennel-rationale.txt|
  • |fennel-values.txt|   • |fennel-lua-primer.txt|

==============================================================================
Elin Module                                                      *elin-module*

Elin adheres to the |fennel-style-guide| but provides camel-case equivalents
for ease of use in lua. A couple of fennel -> lua translations:
• `(elin.get-version)` -> `elin.getVersion()
• `(elin.caching-enabled?)` -> `elin.isCachingEnabled()`

                                                             *elin-happy-path*
This is all I do, and I am happy; therefore, this will make you happy, too:
>fennel
  ;; init.fnl
  (let [{:enable nvim-cache} _G.vim.loader
        {:enable-caching elin-cache} (require :elin)
        {:setup bp-setup (require :backpack)]
    (nvim-cache) ;; enable .lua caching
    (elin-cache) ;; enable .fnl caching
    (bp-setup))  ;; set up pack plugins
  nil
<
Just kidding. See the rest of the help to learn how elin can better suit your
wants and needs for using fennel for neovim config.

                                                                *elin-startup*
Elin bootstraps itself with {elin}/plugin/startup.lua, which is invoked by
neovim during |startup|. This calls |(elin.do-startup)| and creates `:Fnl` and
similar |elin-commands|.

                                                               *elin-init.lua*
If you want to use |init.lua| as your entry point instead (it has a higher
priority and is loaded before plugins like |gzip|, etc), you can! Just
use something like the following:
>lua
  -- init.lua
  vim.loader.enable() -- optional
  local elin = require("elin")
  elin.enableCaching() -- optional
  elin.doStartup { loadInitFnl = true }
>fennel
  ;; init.fnl
  (set vim.g.loaded_gzip 1) ;; disable builtin gzip plugin
  ;; this won't work unless you load init.fnl early with above init.lua!
<
Now just add `.fnl` files to `plugin/`, `ftplugin/`, etc. (see |elin-config|)!

Note: unless you want to prevent builtin plugins or use an |init.lua|, there
is not a benefit to using |init.lua| over |init.fnl|.


(elin.setup {opts})                                             *(elin.setup)*

  Change how elin behaves. Defaults:
>fennel
    (let [{: setup} (require :elin)]
      (setup {:enable-caching false
              :cache-dir (.. (vim.fn.stdpath :cache) :elin)}))
<
  Parameters: ~
  • {opts} (`table?`) options for customizing elin behavior
    • {enable-caching} (`boolean?`) true/nil to enable caching. This is the
      same as invoking |(elin.enable-caching)|.
    • {cache-dir} (`string?`, default: `(.. (vim.fn.stdpath :config) :elin)`)
      directory used for byte-cached `.luac` files.

  Note: Elin is intended to be a drop-in fennel bootstrapper. Therefore, there
  is not much to customize (yet?). If you want something to be more flexible,
  don't hestitate to open an issue or notify me.


(elin.do-startup {opts})                                   *(elin.do-startup)*

  Source |init.fnl| and every |plugin.fnl|. This is invoked implicitly during
  |elin-startup| and uses |(elin.dofile)| to load the fennel files.

  When {do-init-fnl} is not `true` and `init.lua` or `init.vim` exists, do not
  load `init.fnl`. (See |elin-init.lua| to use both an `init.lua` and
  `init.fnl`.)

  Unless {force} is `true`, it guards itself against repetitive invocations.

  Parameters: ~
  • {opts}? (`table?`) Options for `do-startup`:
    • {do-init-fnl}? (`boolean?`) true to always source |init.fnl|.
    • {force}? (`boolean?`) true to force startup again.


(elin.dofile {path} {opts})                                    *(elin.dofile)*

  With caching enabled, use cache to load byte-compiled code associated with
  {path}. Otherwise, this is the same as |(fennel.dofile)|.

  When the cached file doesn't exist or has an `mtime` older than the file at
  {path}, load {path} with |(fennel.dofile)| and store its luajit byte code
  into the cache path, which can be found with |(elin.get-cache-path)|.

  Parameters: ~
  • {opts}? (`table`) Options passed to |(fennel.dofile)|.

  Return: ~
  • (`any`) result of the loaded file or byte code


(elin.get-version)                                        *(elin.get-version)*

  Get elin's version in the format `"v{major}.{minor}.{patch}"`. The current
  version is `v0.0.8`.

  Return: ~
  • (`string`) version


(elin.enable-caching)                                  *(elin.enable-caching)*
(elin.disable-caching)                                *(elin.disable-caching)*
  This is similar to neovim's experimental |vim.loader|, but it caches fennel
  to luajit byte code instead of lua.

  Enable:
  • uses a loader so that `require()` on `.fnl` files uses cached byte code
  • |(elin.dofile)| also uses the byte-compilation cache

  Disable:
  • removes the loader
  • |(elin.dofile)| uses |(fennel.dofile)| always


(elin.caching-enabled?)                              *(elin.caching-enabled?)*
  Check if caching was enabled via |(elin.enable-caching)|

  Return: ~
  • (`boolean`) Caching enabled?


(elin.get-cache-path {path})                           *(elin.get-cache-path)*
(elin.get-uncache-path {cpath})                      *(elin.get-uncache-path)*

  Get a file's cache path from an absolute {path} or get the original path
  from {cpath}. These are complementary functions that reverse the other.

  Example:
>fennel
    (local elin (require :elin))
    (print (elin.get-cache-path "/home/me/foo.fnl"))
    ;; => "/home/me/.cache/nvim/elin/%2fhome%2fme%2ffoo%2efnl.luac"
    (print (elin.get-uncache-path
      "/home/me/.cache/nvim/elin/%2fhome%2fme%2ffoo%2efnl.luac"))
    ;; => "/home/me/foo.fnl"
<
  Parameters: ~
  • {path} / {cpath} (`string`) path / cached path

  Return: ~
  • (`string`) cached / uncached path


(elin.get-cache-dir)                                    *(elin.get-cache-dir)*

  Get the directory where luajit byte-compiled files are stored, which can be
  changed with |(elin.setup)|. |(elin.get-cache-path)| also references
  this setting.

  Return: ~
  • (`string`, default: `(.. (vim.fn.stdpath :cache) :elin)`) cache directory.

==============================================================================
Elin Configuration                                               *elin-config*

If you are already familiar with vim's directory structure, then all you need
to know is that anywhere you can use a `.lua` or `.vim` file, you can use a
`.fnl` file instead, and elin will use it appropriately. This does not apply
to `colors/*.fnl` because we cannot intercept |:colorscheme| on |E185|.

init.fnl, plugin, and lsp files are sourced in order during INIT:
  1. |init.fnl|          (one file)
  2. |plugin.fnl|        (any depth)
  3. |lsp.fnl|           (depth = 1)

When filetype is set, ftplugins and syntax are triggered:
  1. |undo_ftplugin_fnl|
  2. |ftplugin.fnl|
  3. |syntax.fnl|


{config}/init.fnl                                                   *init.fnl*

  Loaded during |elin-startup|, if there is no `init.lua` or `init.vim` file.


{config}/plugin/**/*.fnl                                          *plugin.fnl*
{config}/after/plugin/**/*.fnl                              *after-plugin.fnl*

  Loaded during |elin-startup|. Example:
>fennel
    ;; plugin/opts.fnl
    (set [vim.o.ts vim.o.sts vim.o.et vim.o.sw] [2 2 true 0])
<
  You can disable this with 'noloadplugins' by doing the following:
>fennel
    (set vim.o.loadplugins false)
<
  Warning: If you use |--noplugin|, |elin-startup| will also be disabled
  because it relies on plugin/ to bootstrap itself.


{config}/lsp/*.fnl                                                   *lsp.fnl*

  LSP configurations are extracted and loaded via |vim.lsp.config|; the
  filename must be the name of the lsp server:
>fennel
    ;; lsp/fennel_ls.fnl
    {:lua-version :intersection :lints {:not-enough-arguments true}}
<

`b:undo_ftplugin_fnl`                                      *undo_ftplugin_fnl*
`b:undo_ftplugin_lua`                                      *undo_ftplugin_lua*

  Fennel / Lua expression (string) or function that is evaluated (if defined)
  during |FileType| autocmd (before |ftplugin.fnl|) in order to clean up
  options (etc) set up during the previous filetype plugin. This works as a
  replacement for |undo_ftplugin|.

  Note: elin can't manage `b:undo_ftplugin`, so if a filetype plugin outside
  of your control uses it, then it will be used _in addition_ to
  `b:undo_ftplugin_fnl` or `b:undo_ftplugin_lua`.


{config}/ftplugin/*.fnl                                         *ftplugin.fnl*
{config}/after/ftplugin/*.fnl                             *after-ftplugin.fnl*

  A corresponding filetype plugin is loaded when 'filetype' is set. The
  filename without the `.fnl` suffix must correspond to the filetype.

  If 'filetype' has a '.', this is split and each filetype is used. For
  example, `:set filetype=c.doxygen` will trigger `ftplugin/c.fnl` and
  `ftplugin/doxygen.fnl` to load, if they exist.

  Example:
>fennel
    ;; after/ftplugin/fennel.fnl
    (set vim.bo.formatprg "fnlfmt -")
    (set vim.b.undo_ftplugin_fnl #(set vim.bo.fp nil))
<
  Elin respects |:filetype-plugin-off| and |:filetype-indent-off|:
>fennel
    ;; init.fnl
    (vim.cmd.filetype "plugin off") ;; disables BOTH ftplugin/ AND indent/
    (vim.cmd.filetype "indent off") ;; disables indent/
    ;; Note: this disables ftplugin/indent for .lua, .vim, and .fnl files
<

{config}/syntax/*.fnl                                             *syntax.fnl*
{config}/after/syntax/*.fnl                                 *after/syntax.fnl*

  This isn't very useful because LSP replaced it :)
>fennel
    ;; after/syntax/fennel.fnl
    (vim.opt_local.iskeyword:remove 45) ;; remove "-" from &isk (don't)
    (vim.cmd.syntax "keyword FennelSpecialForm vim")
<
  Elin respects |syntax-off|:
>fennel
    ;; init.fnl
    (vim.cmd.syntax :off)
    ;; Note: this disables syntax for .lua, .vim, and .fnl files
<
  Note: Above {config} is the equal to what you see when you do: >vim
    :echo stdpath("config")  " ~/.config/nvim on unix-y systems
<
  Note: `after/**/*.fnl` is only used if `~/.config/nvim/after` is in
  'runtimepath'. It is by default.

==============================================================================
Fennel Commands                              *elin-commands* *fennel-commands*

Note: :Fnl* commands gobble |bar| like commands listed in |:bar|.


:Fnl[!] [{redir}] {expr}                                                *:Fnl*

  Evaluate {expr} as a fennel expression using the fennel interpreter.

  [!] alters how the `result` is printed. Without [!] the result is printed
  with with `=>` prefix like "=> result". With it, no arrows are printed.

  Note: This is still a work in progress as each {redir} should have its own
  default and [!] can alter how it is displayed. It applies to all commands
  below. We actually probably want to parse our own indicators. Eg, sometimes
  we should use fennel.view(). Sometimes, we should prepend a comment
  (referencing &filetype). Etc.

  If {redir} is not specified, the `result` is printed to the cmdline.
  Otherwise, {redir} specifies if the `result` should into a register, a file,
  a vim or lua variable, or the current buffer. See |:redir|, which shares
  most of the syntax and ability. See |:Fnl-redir|.


:FnlFiles[!] [{redir}] {file} [{file} ...]                         *:FnlFiles*

  Evaluate all {file}s as one fennel expression using the fennel interpreter.

  [!] alters how the `result` is printed. Without [!] the result is printed
  with with `=>` prefix like "=> result". With it, no arrows are printed.

  {redir} applies as with |:Fnl| if specified.


:{range}FnlLines[!] [{redir}]                                      *:FnlLines*

  Evaluate {range} (default current line) as a fennel chunk.

  [!] alters how the `result` is printed. Without [!] the result is printed
  with with `=>` prefix like "=> result". With it, no arrows are printed.

  {redir} applies as with |:Fnl| if specified.


:[{range}]FnlSwiss[!] [{files}] [{redir}] [{files}] [{expr}]       *:FnlSwiss*
  This is all of the above commands merged into one
  tool: a multi-tool. Just like a Swiss army knife, it
  seems cool; but probably no one will ever need or want
  to use it.

  [!] alters how the `result` is printed.
  Without [!] the result is printed with with `=>`
  prefix like "=> result". With it, no arrows are
  printed.

  {range} can be provided like with |:FnlLines|.

  {files} can be provided like with |:FnlFiles|.
  However, each file must be `<` (and optional space)
  and can only come just before and/or after {redir}.

  {expr} can be provided like with |:Fnl|.

  If any are specified, FnlSwiss evaluates the {range}
  first, then all {files} in order, and finally any
  {expr}s.

  {redir} applies as with |:Fnl| if specified.


                                                                  *:Fnl-redir*
{redir} applies to |:Fnl|, |:FnlFile|, |:FnlLines|, and |:FnlSwiss|. It must
be specified before the {expr}. Here is a list of all redirs:

  :Fnl > {file} {expr}     (Always) Write result to {file}.
  :Fnl >> {file} {expr}    Append result to {file}

  :Fnl @{a-zA-Z}> {expr}   Save result to register {a-z}; append if {A-Z}
  :Fnl @{a-zA-Z} {expr}    Same as above (compat)
  :Fnl @{a-z}>> {expr}     Append result to register {a-z}

  :Fnl @{*+"}> {expr}      Save result to `*`, `+`, or `"` register
  :Fnl @{*+"} {expr}       Same as above (compat)
  :Fnl @{*+"}>> {expr}     Append result `*`, `+`, or `"` register
                           (See |quotestar|, |quote+|, and |quotequote|.)

  :Fnl => {var} {expr}     Save result to g:{var} (vim global variable)
  :Fnl =>> {var} {expr}    Append result to g:{var}

The rest are not specified by |:redir| but are supported by |:Fnl|:

  :Fnl -> {var} {expr}     Save result to _G.{var} (lua global variable)
  :Fnl ->> {var} {expr}    Append result to _G.{var}

  :Fnl @_ {expr}           Disregard result (use "black hole" register)
  :Fnl == {expr}           |:put| result

[!] doesn't work like |:redir|. Instead it (currently) removes "> " from the
output for `==` and when `{redir}` isn't provided. This will likely change in
future versions.

Synopsis:
      Redir  Description ~
   > {file}  write `result` to file {file}
  >> {file}  append `result` to file {file}
        @+>  save `result` to register `@+` (same as @+>)
       @a>>  append `result` to register `@a` (same as @A)
   => {var}  save `result` to vim variable `g:`{var}
  =>> {var}  append `result` to vim variable `g:`{var}
   -> {var}  save `result` to lua variable `_G.`{var}
  ->> {var}  append `result` to lua variable `_G.`{var}
         @_  don't print or store `result` (black hole
         ==  |:put| result on new line

Examples: >vim
  " say hi; store "bar" into vim.g.foo
  :Fnl => foo (print "hello from fennel") "bar"
  " evaluate paragraph with fennel and put on next line commented
  :'{,'}FnlLines ==
  " evaluate ~/fennel-test.fnl into @+ register
  :FnlFiles @+> ~/fennel-test.fnl
  " eval from line to end of buffer and file ~/utils.fnl; store 9 into _G.Res
  :.,$FnlSwiss -> Res < ~/utils.fnl (sum 2 3 4)


:FnlRepl[!]                                                         *:FnlRepl*

  Start a fennel repl in a split window. With [!], start it in a floating
  window.

  Use <C-l> in insert mode to move the current line to the top (it doesn't
  clear the buffer to preserve the scrollback.

  Use <C-d> in insert mode on an empty line to exit the repl.

==============================================================================
Lore                                                             *elin-lore*

In addition to an acronym, Elin is a name that means "shining" or "brilliant".
In other words, it brings a little light from the world of lisp into neovim.

Conversely, ~evil-mode~ steals some good vim concepts and embeds them into its
dark world of ~emacs~. ;)

Pronounce the plugin name however you want! I pronounce it /ee-lin/ (like
elisp), but the name is probably pronounced /eh-lin/ :)

                                |
                         |     -*-
                        -*-     |
                         |                            |
  |                                                  -*-
 -*-                                                  |
  |                                           |
       |                                     -*-
      -*-                                     |                  |
       |                                                        -*-
                                                                 |

==============================================================================
<3                                                             *elin-thanks*

A special thanks to the fennel contributors and hotpot.nvim for the hard work
necessary to make this project viable and inspiration. Thanks also to
fennel-ls and fennel-ls-nvim-docs.

https://fennel-lang.org/                              `|`
https://git.sr.ht/~xerool/fennel-ls                  `-*-`
https://github.com/rktjmp/hotpot.nvim                 `|`
https://dev.fennel-lang.org/wiki/WikiStart
https://git.sr.ht/~micampe/fennel-ls-nvim-docs

Thanks also to other projects that bring fennel into neovim. You all make the
fennel ecosystem a little brighter.

https://github.com/Olical/nfnl                `|`
https://github.com/Olical/aniseed            `-*-`
https://github.com/jaawerth/fennel.vim        `|`
https://github.com/jaawerth/fennel-nvim                            `|`
https://github.com/gpanders/nvim-moonwalk                         `-*-`
https://github.com/alexaandru/fennel-nvim                          `|`
https://github.com/udayvir-singh/tangerine.nvim
 vim:tw=78:ts=2:et:ft=help:norl:
