*elin.txt*            Extensible Lisp Integration for Neovim            *elin*
>
                                 ,dPb,    |
                                 IP"Yb   -*-
                        |        I8 8P gg |
                       -*-       db 8I ""             |
                        |  ,gg,  d8 8" gg  ,gg, ,gg  -*-
                          i8" 8i I8dP  88 ,8PY8YP"g8, |
                          8I ,8I I8P   d8 I8  8I   8i
                        _,Igd8P,,d8b,_,88,dP  8I   "8,
                       888P""Y888P'"Y8P""8P'  8I    "8i
<
                              for Neovim `+v0.8.0`
==============================================================================
About                                                             *elin-about*

Elin enhances neovim with seamless fennel configuration. Just write `.fnl`
files where you would normally write `.lua` or `.vim` files. For more info,
see |elin-config|.

Fennel is a lisp that compiles directly to lua or evaluates fennel using a lua
interpreter. Elin uses neovim's |lua-luajit| to bootstrap fennel on top and
tries to make it as comfortable to use `.fnl` files as it is to use `.lua`
files everywhere.

There are also some nice commands for evaluating fennel in various ways. Check
out |fennel-commands|.
                                                             *elin-fennel-toc*
For your convenience, some reference help documents, with the good graces of
the fennel maintainers, are ported and distributed with this plugin:

  • |fennel-tutorial.txt| • |fennel-reference.txt|   • |fennel-api.txt
  • |fennel-macros.txt|   • |fennel-style.txt|       • |fennel-rationale.txt|
  • |fennel-values.txt|   • |fennel-lua-primer.txt|

==============================================================================
Elin Module                                                      *elin-module*

Elin adheres to the |fennel-style-guide| but provides camel-case equivalents
for ease of use in lua. A couple of fennel -> lua translations:
• `(elin.get-version)` -> `elin.getVersion()
• `(elin.caching-enabled?)` -> `elin.isCachingEnabled()`

                                                             *elin-happy-path*
This is all I do, and I am happy; therefore, this will make you happy, too:
>fennel
  ;; init.fnl
  (let [{:enable nvim-cache} _G.vim.loader
        {:enable-caching elin-cache} (require :elin)
        {:setup bp-setup (require :backpack)]
    (nvim-cache) ;; enable .lua caching
    (elin-cache) ;; enable .fnl caching
    (bp-setup))  ;; set up pack plugins
  nil
<
Just kidding. See the rest of the help to learn how elin can better suit your
wants and needs for using fennel for neovim config.

                                                                *elin-startup*
Elin bootstraps itself with {elin}/plugin/startup.lua, which is invoked by
neovim during |startup|. This calls |(elin.do-startup)| and creates `:Fnl` and
similar |elin-commands|.

                                                               *elin-init.lua*
If you want to use |init.lua| as your entry point instead (it has a higher
priority and is loaded before plugins like |gzip|, etc), you can! Just
use something like the following:
>lua
  -- init.lua
  vim.loader.enable() -- optional
  local elin = require("elin")
  elin.enableCaching() -- optional
  elin.doStartup { loadInitFnl = true }
>fennel
  ;; init.fnl
  (set vim.g.loaded_gzip 1) ;; disable builtin gzip plugin
  ;; this won't work unless you load init.fnl early with above init.lua!
<
Now just add `.fnl` files to `plugin/`, `ftplugin/`, etc. (see |elin-config|)!

Note: unless you want to prevent builtin plugins or use an |init.lua|, there
is not a benefit to using |init.lua| over |init.fnl|.


(elin.setup {opts})                                             *(elin.setup)*

  Change how elin behaves. Defaults:
>fennel
    (let [{: setup} (require :elin)]
      (setup {:enable-caching false
              :cache-dir (.. (vim.fn.stdpath :cache) :elin)}))
<
  Parameters: ~
  • {opts} (`table?`) options for customizing elin behavior
    • {enable-caching} (`boolean?`) true/nil to enable caching. This is the
      same as invoking |(elin.enable-caching)|.
    • {cache-dir} (`string?`, default: `(.. (vim.fn.stdpath :config) :elin)`)
      directory used for byte-cached `.luac` files.

  Note: Elin is intended to be a drop-in fennel bootstrapper. Therefore, there
  is not much to customize (yet?). If you want something to be more flexible,
  don't hestitate to open an issue or notify me.


(elin.do-startup {opts})                                   *(elin.do-startup)*

  Source |init.fnl| and every |plugin.fnl|. This is invoked implicitly during
  |elin-startup| and uses |(elin.dofile)| to load the fennel files.

  When {do-init-fnl} is not `true` and `init.lua` or `init.vim` exists, do not
  load `init.fnl`. (See |elin-init.lua| to use both an `init.lua` and
  `init.fnl`.)

  Unless {force} is `true`, it guards itself against repetitive invocations.

  Parameters: ~
  • {opts}? (`table?`) Options for `do-startup`:
    • {do-init-fnl}? (`boolean?`) true to always source |init.fnl|.
    • {force}? (`boolean?`) true to force startup again.


(elin.dofile {path} {opts})                                    *(elin.dofile)*

  With caching enabled, use cache to load byte-compiled code associated with
  {path}. Otherwise, this is the same as |(fennel.dofile)|.

  When the cached file doesn't exist or has an `mtime` older than the file at
  {path}, load {path} with |(fennel.dofile)| and store its luajit byte code
  into the cache path, which can be found with |(elin.get-cache-path)|.

  Parameters: ~
  • {opts}? (`table`) Options passed to |(fennel.dofile)|.

  Return: ~
  • (`any`) result of the loaded file or byte code


(elin.get-version)                                        *(elin.get-version)*

  Get elin's version in the format `"v{major}.{minor}.{patch}"`. The current
  version is `v0.0.8`.

  Return: ~
  • (`string`) version


(elin.enable-caching)                                  *(elin.enable-caching)*
(elin.disable-caching)                                *(elin.disable-caching)*

  This is similar to neovim's experimental |vim.loader|, but it caches fennel
  to luajit byte code instead of lua.

  Enable:
  • uses a loader so that `require()` on `.fnl` files uses cached byte code
  • |(elin.dofile)| also uses the byte-compilation cache

  Disable:
  • removes the loader
  • |(elin.dofile)| uses |(fennel.dofile)| always


(elin.caching-enabled?)                              *(elin.caching-enabled?)*
  Check if caching was enabled via |(elin.enable-caching)|

  Return: ~
  • (`boolean`) Caching enabled?


(elin.get-cache-path {path})                           *(elin.get-cache-path)*
(elin.get-uncache-path {cpath})                      *(elin.get-uncache-path)*

  Get a file's cache path from an absolute {path} or get the original path
  from {cpath}. These are complementary functions that reverse the other.

  Example:
>fennel
    (local elin (require :elin))
    (print (elin.get-cache-path "/home/me/foo.fnl"))
    ;; => "/home/me/.cache/nvim/elin/%2fhome%2fme%2ffoo%2efnl.luac"
    (print (elin.get-uncache-path
      "/home/me/.cache/nvim/elin/%2fhome%2fme%2ffoo%2efnl.luac"))
    ;; => "/home/me/foo.fnl"
<
  Parameters: ~
  • {path} / {cpath} (`string`) path / cached path

  Return: ~
  • (`string`) cached / uncached path


(elin.get-cache-dir)                                    *(elin.get-cache-dir)*

  Get the directory where luajit byte-compiled files are stored, which can be
  changed with |(elin.setup)|. |(elin.get-cache-path)| also references
  this setting.

  Return: ~
  • (`string`, default: `(.. (vim.fn.stdpath :cache) :elin)`) cache directory.


==============================================================================
Fennel to Lua                                         *fnl2lua* *elin-fnl2lua*

`fnl2lua` compiles fennel files in fennel projects to lua files! It can be
automatically run by adding |(fnl2lua.enable)| to your |init.fnl|. This is a
submodule of `elin`, so use `(require :elin.fnl2lua)`.


(fnl2lua.compile {file})                                   *(fnl2lua.compile)*

  Compile the fennel {file} to its respective lua output using the following
  strategy:
    • find the project's `root` directory via |fnl2lua-markers|
    • set output file's path relative to `(.. root "/lua/" rel-file ".lua")`
      • `rel-file` is the path to {file} from the project's root directory
      • a `"fnl/"` prefix is stripped from `rel-file` 

  Note: {file} must be in a project with a `root` directory containing a
        `flsproject.fnl`, `.git/` dir, or `init.fnl`.

  For example, here are two directory structures (represented using a `tree`
  output) before and after the file, `fnl/foo.fnl` is written:

    Before                After ~
    .                     .              
    ├── flsproject.fnl    ├── flsproject.fnl
    ├── fnl               ├── fnl           
        └── foo.fnl       │   └── foo.fnl
                          └── lua        
                              └── foo.lua

  Parameters: ~
  • {file}? (`string`) the input file to compile. If `nil`, use the file
    associated with the current buffer.



(fnl2lua.set-ignore-dirs {ignores})                *(fnl2lua.set-ignore-dirs)*

  Disallow |fnl2lua| in projects when the {file}'s project root is in
  {ignores}.

  The ignores list defaults to just the neovim config directory, as seen
  below. This is highly encouraged when caching is enabled (see
  |(elin.enable-caching)|). Otherwise, you will get duplicated code.
  >fennel
    (let [{: enable-caching
          : enable-fnl2lua
          : set-ignore-dirs} (require :elin.fnl2lua)]
      ;; auto-cache fennel files in ~/.config/nvim
      (enable-caching)
      ;; and auto-compile fennel files in all fennel projects
      (fnl2lua)
      ;; but ignore *.fnl files in ~/.config/nvim (necessary!)
      (set-ignore-dirs [(vim.fn.stdpath :config)]))
<
  Note: for clarity, you don't need to call `fnl2lua-set-ignore` as above,
  since this is already the default.

  Parameters: ~
  • {ignores} (`string[]`) A list of root projects in which fennel files
    should not be automatically compiled (when `fnl2lua` is enabled).


(fnl2lua.add-ignore-dir {path})                     *(fnl2lua.add-ignore-dir)*
(fnl2lua.remove-ignore-dir {path}                *(fnl2lua.remove-ignore-dir)*

  Add/remove {path} to project {ignores}, as explained in
  |(fnl2lua.set-ignore-dirs)|.

  Parameters: ~
  • {path} (`string`) A path to add/remove (resp.) from the list of {ignores}.


(fnl2lua.get-ignore-dirs)                          *(fnl2lua.get-ignore-dirs)*

  Get the list of ignored project directories.
  
  Return: ~
  • (`string[]|nil`) list of directories that are ignored by `fnl2lua` when
    detected as the project root


(fnl2lua.enable [{callback}])                          *(fnl2lua.enable)*
(fnl2lua.disable)                                     *(fnl2lua.disable)*

  Enable or disable the `fnl2lua` feature. The only "strategy" at the moment
  is to use |BufWritePost| with a `*.fnl` pattern and passing <amatch> to
  |(fnl2lua.compile)|. To use an alternative compilation technique, pass
  your own {callback} function.

  You must add the following to your |init.fnl| to enable automatic
  compilation: >fennel
    ;; init.fnl
    (let [{: enable-fnl2lua} (require :elin)]
      (enable-fnl2lua))
<
  Parameters: ~
  • {callback}? (`function`) callback to use in place of
    |(fnl2lua.compile)|.


                                    *fnl2lua-project-marker* *fnl2lua-markers*

fnl2lua {markers} are paths that are present in the root of a project
directory. They are represented as a list of strings. If |(fnl2lua.enable)| is
used, each |BufWritePost| on `*.fnl` files uses these markers to determine
where the project root is in order to automatically compile (potentially
nested fennel files) to their lua counterparts.

The default is `[:.git/ :flsproject.fnl :init.fnl]`. Change it with
|(fnl2lua.set-project-markers)|.

Note: strings that end with a `/` are strictly treated as a directory and
      otherwise as a file.

(fnl2lua.set-project-markers {markers}         *(fnl2lua.set-project-markers)*

  Parameters: ~
  • {markers} (`string[]`) project markers; directories should end with `/`.

==============================================================================
Elin Configuration                                               *elin-config*

If you are already familiar with vim's directory structure, then all you need
to know is that anywhere you can use a `.lua` or `.vim` file, you can use a
`.fnl` file instead, and elin will use it appropriately. This does not apply
to `colors/*.fnl` because we cannot intercept |:colorscheme| on |E185|.

init.fnl, plugin, and lsp files are sourced in order during INIT:
  1. |init.fnl|          (one file)
  2. |plugin.fnl|        (any depth)
  3. |lsp.fnl|           (depth = 1)

When filetype is set, ftplugins and syntax are triggered:
  1. |undo_ftplugin_fnl|
  2. |ftplugin.fnl|
  3. |syntax.fnl|


{config}/init.fnl                                                   *init.fnl*

  Loaded during |elin-startup|, if there is no `init.lua` or `init.vim` file.


{config}/plugin/**/*.fnl                                          *plugin.fnl*
{config}/after/plugin/**/*.fnl                              *after-plugin.fnl*

  Loaded during |elin-startup|. Example:
>fennel
    ;; plugin/opts.fnl
    (set [vim.o.ts vim.o.sts vim.o.et vim.o.sw] [2 2 true 0])
<
  You can disable this with 'noloadplugins' by doing the following:
>fennel
    (set vim.o.loadplugins false)
<
  Warning: If you use |--noplugin|, |elin-startup| will also be disabled
  because it relies on plugin/ to bootstrap itself.


{config}/lsp/*.fnl                                                   *lsp.fnl*

  LSP configurations are extracted and loaded via |vim.lsp.config|; the
  filename must be the name of the lsp server:
>fennel
    ;; lsp/fennel_ls.fnl
    {:lua-version :intersection :lints {:not-enough-arguments true}}
<

`b:undo_ftplugin_fnl`                                      *undo_ftplugin_fnl*
`b:undo_ftplugin_lua`                                      *undo_ftplugin_lua*

  Fennel / Lua expression (string) or function that is evaluated (if defined)
  during |FileType| autocmd (before |ftplugin.fnl|) in order to clean up
  options (etc) set up during the previous filetype plugin. This works as a
  replacement for |undo_ftplugin|.

  Note: elin can't manage `b:undo_ftplugin`, so if a filetype plugin outside
  of your control uses it, then it will be used _in addition_ to
  `b:undo_ftplugin_fnl` or `b:undo_ftplugin_lua`.


{config}/ftplugin/*.fnl                                         *ftplugin.fnl*
{config}/after/ftplugin/*.fnl                             *after-ftplugin.fnl*

  A corresponding filetype plugin is loaded when 'filetype' is set. The
  filename without the `.fnl` suffix must correspond to the filetype.

  If 'filetype' has a '.', this is split and each filetype is used. For
  example, `:set filetype=c.doxygen` will trigger `ftplugin/c.fnl` and
  `ftplugin/doxygen.fnl` to load, if they exist.

  Example:
>fennel
    ;; after/ftplugin/fennel.fnl
    (set vim.bo.formatprg "fnlfmt -")
    (set vim.b.undo_ftplugin_fnl #(set vim.bo.fp nil))
<
  Elin respects |:filetype-plugin-off| and |:filetype-indent-off|:
>fennel
    ;; init.fnl
    (vim.cmd.filetype "plugin off") ;; disables BOTH ftplugin/ AND indent/
    (vim.cmd.filetype "indent off") ;; disables indent/
    ;; Note: this disables ftplugin/indent for .lua, .vim, and .fnl files
<

{config}/syntax/*.fnl                                             *syntax.fnl*
{config}/after/syntax/*.fnl                                 *after/syntax.fnl*

  This isn't very useful because LSP replaced it :)
>fennel
    ;; after/syntax/fennel.fnl
    (vim.opt_local.iskeyword:remove 45) ;; remove "-" from &isk (don't)
    (vim.cmd.syntax "keyword FennelSpecialForm vim")
<
  Elin respects |syntax-off|:
>fennel
    ;; init.fnl
    (vim.cmd.syntax :off)
    ;; Note: this disables syntax for .lua, .vim, and .fnl files
<
  Note: Above {config} is the equal to what you see when you do: >vim
    :echo stdpath("config")  " ~/.config/nvim on unix-y systems
<
  Note: `after/**/*.fnl` is only used if `~/.config/nvim/after` is in
  'runtimepath'. It is by default.

==============================================================================
Fennel Commands                              *elin-commands* *fennel-commands*

Note: :Fnl* commands gobble |bar| like commands listed in |:bar|.


:Fnl[!] [{redir}] {expr}                                                *:Fnl*

  Evaluate {expr} as a fennel expression using the fennel interpreter.

  [!] alters how the `result` is printed. Without [!] the result is printed
  with with `=>` prefix like "=> result". With it, no arrows are printed.

  Note: This is still a work in progress as each {redir} should have its own
  default and [!] can alter how it is displayed. It applies to all commands
  below. We actually probably want to parse our own indicators. Eg, sometimes
  we should use fennel.view(). Sometimes, we should prepend a comment
  (referencing &filetype). Etc.

  If {redir} is not specified, the `result` is printed to the cmdline.
  Otherwise, {redir} specifies if the `result` should into a register, a file,
  a vim or lua variable, or the current buffer. See |:redir|, which shares
  most of the syntax and ability. See |:Fnl-redir|.


:FnlFiles[!] [{redir}] {file} [{file} ...]                         *:FnlFiles*

  Evaluate all {file}s as one fennel expression using the fennel interpreter.

  [!] alters how the `result` is printed. Without [!] the result is printed
  with with `=>` prefix like "=> result". With it, no arrows are printed.

  {redir} applies as with |:Fnl| if specified.


:{range}FnlLines[!] [{redir}]                                      *:FnlLines*

  Evaluate {range} (default current line) as a fennel chunk.

  [!] alters how the `result` is printed. Without [!] the result is printed
  with with `=>` prefix like "=> result". With it, no arrows are printed.

  {redir} applies as with |:Fnl| if specified.


:[{range}]FnlSwiss[!] [{files}] [{redir}] [{files}] [{expr}]       *:FnlSwiss*
  This is all of the above commands merged into one
  tool: a multi-tool. Just like a Swiss army knife, it
  seems cool; but probably no one will ever need or want
  to use it.

  [!] alters how the `result` is printed.
  Without [!] the result is printed with with `=>`
  prefix like "=> result". With it, no arrows are
  printed.

  {range} can be provided like with |:FnlLines|.

  {files} can be provided like with |:FnlFiles|.
  However, each file must be `<` (and optional space)
  and can only come just before and/or after {redir}.

  {expr} can be provided like with |:Fnl|.

  If any are specified, FnlSwiss evaluates the {range}
  first, then all {files} in order, and finally any
  {expr}s.

  {redir} applies as with |:Fnl| if specified.


                                                                  *:Fnl-redir*
{redir} applies to |:Fnl|, |:FnlFile|, |:FnlLines|, and |:FnlSwiss|. It must
be specified before the {expr}. Here is a list of all redirs:

  :Fnl > {file} {expr}     (Always) Write result to {file}.
  :Fnl >> {file} {expr}    Append result to {file}

  :Fnl @{a-zA-Z}> {expr}   Save result to register {a-z}; append if {A-Z}
  :Fnl @{a-zA-Z} {expr}    Same as above (compat)
  :Fnl @{a-z}>> {expr}     Append result to register {a-z}

  :Fnl @{*+"}> {expr}      Save result to `*`, `+`, or `"` register
  :Fnl @{*+"} {expr}       Same as above (compat)
  :Fnl @{*+"}>> {expr}     Append result `*`, `+`, or `"` register
                           (See |quotestar|, |quote+|, and |quotequote|.)

  :Fnl => {var} {expr}     Save result to g:{var} (vim global variable)
  :Fnl =>> {var} {expr}    Append result to g:{var}

The rest are not specified by |:redir| but are supported by |:Fnl|:

  :Fnl -> {var} {expr}     Save result to _G.{var} (lua global variable)
  :Fnl ->> {var} {expr}    Append result to _G.{var}

  :Fnl @_ {expr}           Disregard result (use "black hole" register)
  :Fnl == {expr}           |:put| result

[!] doesn't work like |:redir|. Instead it (currently) removes "> " from the
output for `==` and when `{redir}` isn't provided. This will likely change in
future versions.

Synopsis:
      Redir  Description ~
   > {file}  write `result` to file {file}
  >> {file}  append `result` to file {file}
        @+>  save `result` to register `@+` (same as @+>)
       @a>>  append `result` to register `@a` (same as @A)
   => {var}  save `result` to vim variable `g:`{var}
  =>> {var}  append `result` to vim variable `g:`{var}
   -> {var}  save `result` to lua variable `_G.`{var}
  ->> {var}  append `result` to lua variable `_G.`{var}
         @_  don't print or store `result` (black hole
         ==  |:put| result on new line

Examples: >vim
  " say hi; store "bar" into vim.g.foo
  :Fnl => foo (print "hello from fennel") "bar"
  " evaluate paragraph with fennel and put on next line commented
  :'{,'}FnlLines ==
  " evaluate ~/fennel-test.fnl into @+ register
  :FnlFiles @+> ~/fennel-test.fnl
  " eval from line to end of buffer and file ~/utils.fnl; store 9 into _G.Res
  :.,$FnlSwiss -> Res < ~/utils.fnl (sum 2 3 4)


:FnlRepl[!]                                                         *:FnlRepl*

  Start a fennel repl in a split window. With [!], start it in a floating
  window.

  Use <C-l> in insert mode to move the current line to the top (it doesn't
  clear the buffer to preserve the scrollback.

  Use <C-d> in insert mode on an empty line to exit the repl.

==============================================================================
Checkhealth                                                 *elin-checkhealth*

:checklealth elin

  Like most plugins, you can use `:checkhealth elin` to ensure that it is
  loaded and operating correctly. See |:checkhealth| for more information.

==============================================================================
Lore                                                             *elin-lore*

Elin stands for "Extensible Lisp Integration for Neovim". In addition to an
acronym, Elin is a name that means "shining" or "brilliant". In other words,
it brings a little light from the world of lisp into neovim.

Conversely, ~evil-mode~ steals some good vim concepts and embeds them into its
dark world of ~emacs~. ;)

Pronounce the plugin name however you want! I pronounce it /ee-lin/ (like
elisp), but the name is probably pronounced /eh-lin/ :)

                                |
                         |     -*-
                        -*-     |
                         |                            |
  |                                                  -*-
 -*-                                                  |
  |                                           |
       |                                     -*-
      -*-                                     |                  |
       |                                                        -*-
                                                                 |

==============================================================================
<3                                                             *elin-thanks*

A special thanks to the fennel contributors and hotpot.nvim for the hard work
necessary to make this project viable and inspiration. Thanks also to
fennel-ls and fennel-ls-nvim-docs.

https://fennel-lang.org/                              `|`
https://git.sr.ht/~xerool/fennel-ls                  `-*-`
https://github.com/rktjmp/hotpot.nvim                 `|`
https://dev.fennel-lang.org/wiki/WikiStart
https://git.sr.ht/~micampe/fennel-ls-nvim-docs

Thanks also to other projects that bring fennel into neovim. You all make the
fennel ecosystem a little brighter.

https://github.com/Olical/nfnl                `|`
https://github.com/Olical/aniseed            `-*-`
https://github.com/jaawerth/fennel.vim        `|`
https://github.com/jaawerth/fennel-nvim                            `|`
https://github.com/gpanders/nvim-moonwalk                         `-*-`
https://github.com/alexaandru/fennel-nvim                          `|`
https://github.com/udayvir-singh/tangerine.nvim


 vim:tw=78:isk=!-~,^*,^\|,^\":ts=2:et:ft=help:norl:
