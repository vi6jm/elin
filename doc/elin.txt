*elin.txt*            Extensible Lisp Integration for Neovim            *elin*
>
                                 ,dPb,    |
                                 IP"Yb   -*-
                        |        I8 8P gg |
                       -*-       db 8I ""             |
                        |  ,gg,  d8 8" gg  ,gg, ,gg  -*-
                          i8" 8i I8dP  88 ,8PY8YP"g8, |
                          8I ,8I I8P   d8 I8  8I   8i
                        _,Igd8P,,d8b,_,88,dP  8I   "8,
                       888P""Y888P'"Y8P""8P'  8I    "8i
<
                              for Neovim `+v0.8.0`
==============================================================================
About                                                           *elin-about*

Elin enhances neovim with seamless fennel configuration. Just write `.fnl`
files where you would normally write `.lua` or `.vim` files. For more info,
see |elin-config|.

Fennel is a lisp that compiles directly to lua or evaluates fennel using a lua
interpreter. Elin uses neovim's |lua-luajit| to bootstrap fennel on top and
tries to make it as comfortable to use `.fnl` files as it is to use `.lua`
files everywhere.

There are also some nice commands for evaluating fennel in various ways. Check
out |fennel-commands|.
                                                             *elin-fennel-toc*
For your convenience, some reference help documents, with the good graces of
the fennel maintainers, are ported and distributed with this plugin:
- |fennel-tutorial.txt|
- |fennel-reference.txt|
- |fennel-api.txt|
- |fennel-macros.txt|
- |fennel-style.txt|
- |fennel-rationale.txt|
- |fennel-values.txt|
- |fennel-lua-primer.txt|

==============================================================================
Elin Module                                                      *elin-module*

Note: as demonstrated below, the elin module has both functions that are easy
to use in lua as well as names that adhere to the |fennel-style-guide|.

                                                  *elin.setup()* *(elin.setup)
Elin intends to be a drop-in bootstrapper for fennel, but the defaults may not
be what you want. In this case, you can require the elin module and use its
`.setup()` to better suit your preferences: >fennel
  ;; init.fnl
  (vim.loader.enable) ;; call before (fennel.enable-caching)
  (let [{: setup : enable-caching} (require :elin)]
    (setup {:cache-dir :/tmp/elin-cache/})
    (enable-caching))
>lua
  -- init.lua (alternative)
  local elin = require("elin")
  elin.setup { cacheDir = "/tmp/elin-cache/" }
  vim.loader.enable()
  elin.enableCaching()

At the moment, there isn't much to tweak: only `cache-dir` (alternatively,
`cacheDir`). This is easily remedied; don't hesitate to submit an issue if you
want something to be more customizable.

                                      *elin.getVersion()* *(elin.get-version)*
Use these functions to get elin's version in the format
`v{major}.{minor}.{patch}`. The current version is `v0.0.6`. >fennel
  ;; init.fnl
  (let [{: get-version} (require :elin)]
    (print "Elin version:" (get-version)))
  ;; => Elin version: v0.0.6
>lua
  -- init.lua (alternative)
  local elin = require("elin")
  print("Elin version:", elin.getVersion())
  -- => Elin version: v0.0.6
<
                                                  *elin-caching* *elin-loader*
Elin can inject a package loader that will automatically cache fennel modules
when required, so that neovim initializes faster. It does this by storing
luajit byte code in `stdpath("cache") .. "/elin/"`. This is considered
experimental, so you have enable the loader manually.

You can also pair this with neovim's experimental loader, |vim.loader|. I'm
seeing 70ms speedup using both.

                           *elin.isCachingEnabled()* *(elin.caching-enabled?)*
                           *elin.enableCaching()*    *(elin.enable-caching)*
                           *elin.disableCaching()*   *(elin.disable-caching)*
Note: Be sure that you enable vim's loader before elin's loader.
>fennel
  ;; init.fnl
  (vim.loader.enable) ;; enable before (enable-caching) or not at all
  (let [{: enable-caching : caching-enabled?} (require :elin)]
    (enable-caching)
    (print "Elin caching is enabled?" (caching-enabled?)))
    ;; => Elin caching is enabled? true

With caching enabled, using |require()| will auto-cache `.fnl` to `.luac`
files for faster loading in future neovim sessions. Additionally, files loaded
during |ftplugin.fnl| will also be auto-cached in the same way.

Enabling caching, therefore, enables both the storing (for |require()| and
filetype plugins or anything that |(elin.dofile)| evaluates) and detection of
cached `.luac` files.

                                                              *elin-utilities*
Elin also exposes functions it uses internally to manage plugins, filetype
plugins, the caching loader, etc. Feel free to use them where needed.

                                               *elin.dofile()* *(elin.dofile)*
This respects |elin-caching|. If not enabled, then it simply calls
|(fennel.dofile)|.
>fennel
  ;; plugin/snippets.fnl
  (local get-rtp-file _G.vim.api.nvim_get_runtime_file)
  (fn activate-snippets []
    "source &rtp/snippets/activate.fnl"
    (case (. (get-rtp-file :snippets/activate.fnl false) 1)
      snip-activ-path (let [{: dofile}] (require :eline)
                        (dofile snip-activ-path))
      _ (print "Fatal: Unable to find &rtp/snippets/activate.fnl")))
<
                             *elin.getCachePath()*   *(elin.get-cache-path)*
                             *elin.getUncachePath()* *(elin.get-uncache-path)*
                             *elin.getCacheDir()*    *(elin.get-cache-dir)*
When |elin-caching| is enabled, it uses `get-cache-path` to turn an absolute
path into an encoded path in the `cache dir`. Remember, you can set the
`cache dir` with |(elin.setup)|. If you need to, you can also find the
absolute path of a cached file path using `get-uncache-path`:
>fennel
  ;; plugin/test.fnl
  (let [a-path (.. (vim.fn.stdpath :config) :/a/file.fnl)
        {: setup
        : get-cache-path
        : get-uncache-path
        : get-cache-dir} (:require elin)]
    (setup {:cache-dir (.. (vim.fn.stdpath :cache) :foo))
    (print (get-cache-dir))
    (print (get-cache-path a-path))
    (print (get-uncache-path (get-cache-path a-path))))
  ;; stdout:
  ; /home/me/.cache/nvim/foo/
  ; /home/me/.cache/foo/%2fhome%2fme%2f%2econfig%2fnvim%2fa%2ffile%2efnl.luac
  ; /home/me/.config/nvim/a/file.fnl

==============================================================================
Elin Configuration                                               *elin-config*

If you are already familiar with vim's directory structure, then all you need
to know is that anywhere you can use a `.lua` or `.vim` file, you can use a
`.fnl` file instead, and elin will use it appropriately. This does not apply
to `colors/*.fnl` because we cannot intercept |:colorscheme| on |E185|.

init.fnl, plugin, and lsp files are sourced in order during INIT:
1. |init.fnl|          one file
2. |plugin.fnl|        any depth
3. |after-plugin.fnl|  any depth
4. |lsp.fnl|           depth=1

When filetype is set, ftplugins and syntax are triggered:
1. |undo_ftplugin_fnl|
3. |ftplugin.fnl|
4. |after-ftplugin.fnl
5. |syntax.fnl|
6. |after-syntax.fnl


{config}/init.fnl                                                   *init.fnl*

  If there is no |init.lua| or |init.vim|, elin will load |init.fnl|. This
  can't happen during |startup|, but it does happen during INIT when neovim is
  sourcing files in `plugin/**`. TODO: see elin.setup()


{config}/plugin/**/*.fnl                                          *plugin.fnl*
{config}/after/plugin/**/*.fnl                              *after-plugin.fnl*

  Plugins are loaded during INIT: >fennel
    ;; plugin/opts.fnl
    (set [vim.o.ts vim.o.sts vim.o.et vim.o.sw] [2 2 true 0])
<
  Disable with |--noplugin| or 'loadplugins'.  Since, |init.fnl| is loaded
  first, you can disable them if desired: >fennel
    ;; init.fnl
    (set vim.o.loadplugins false)


{config}/lsp/*.fnl                                                   *lsp.fnl*

  LSP configurations are extracted and loaded via |vim.lsp.config|: >fennel
    ;; lsp/fennel_ls.fnl
    {:lua-version :intersection :lints {:not-enough-arguments true}}


b:undo_ftplugin_fnl                                        *undo_ftplugin_fnl*
b:undo_ftplugin_lua                                        *undo_ftplugin_lua*

  Set `b:undo_ftplugin_fnl` to a fennel expression (string) or fennel function
  (which is the same as a lua function). `b:undo_ftplugin_lua` is the same but
  for lua expressions and functions. See |ftplugin.fnl| for an example.


{config}/ftplugin/*.fnl                                         *ftplugin.fnl*
{config}/after/ftplugin/*.fnl                             *after-ftplugin.fnl*

  A corresponding filetype plugin is loaded when 'filetype' is set. The
  filename without the `.fnl` suffix must be the 'filetype': >fennel
    ;; after/ftplugin/fennel.fnl
    (set vim.bo.formatprg "fnlfmt -")
    (set vim.b.undo_ftplugin_fnl "(set vim.bo.fp nil)")
<
  Note: A 'filetype' can have a ".", which is supported. Each fennel filetype
        plugin will be sourced accordingly.
<
  To disable (see |:filetype-plugin-off|, |:filetype-indent-off|): >fennel
    ;; init.fnl
    (vim.cmd.filetype "plugin off") ;; disables BOTH ftplugin/ AND indent/
    (vim.cmd.filetype "indent off") ;; disables indent/
<
  Note: these disable plugin/indent for `.lua,` `.vim,` and `.fnl` files.


{config}/syntax/*.fnl                                             *syntax.fnl*
{config}/after/syntax/*.fnl                                 *after/syntax.fnl*

  This isn't very useful because LSP replaced it :) >fennel
    ;; after/syntax/fennel.fnl
    (vim.opt_local.iskeyword:remove 45) ;; remove "-" from &isk (don't)
    (vim.cmd.syntax "keyword FennelSpecialForm vim")
<
  Disable syntax (see |syntax-off|): >fennel
    ;; init.fnl
    (vim.cmd.syntax :off)
    ;; Note: this disables syntax for .lua, .vim, and .fnl files
<
  Note: Above {config} is the equal to what you see when you do: >vim
          :echo stdpath("config")  " ~/.config/nvim on unix-y systems
<
  Note: `after/**/*.fnl` is only used if `~/.config/nvim/after` is in
        'runtimepath'. It is by default.

  Note: INIT above refers to elin's initialization, which happens when
        `plugin/startup.lua` is loaded during nvim's |startup|.

==============================================================================
Fennel Commands                              *elin-commands* *fennel-commands*

Note: :Fnl* commands gobble |bar| like commands listed in |:bar|.


:Fnl[!] [{redir}] {expr}                                                *:Fnl*
  Evaluate {expr} as a fennel expression using the fennel interpreter.

  [!] alters how the `result` is printed. Without [!] the result is printed
  with with `=>` prefix like "=> result". With it, no arrows are printed.

  Note: This is still a work in progress as each {redir} should have its own
  default and [!] can alter how it is displayed. It applies to all commands
  below. We actually probably want to parse our own indicators. Eg, sometimes
  we should use fennel.view(). Sometimes, we should prepend a comment
  (referencing &filetype). Etc.

  If {redir} is not specified, the `result` is printed to the cmdline.
  Otherwise, {redir} specifies if the `result` should into a register, a file,
  a vim or lua variable, or the current buffer. See |:redir|, which shares
  most of the syntax and ability. See |:Fnl-redir|.


:FnlFiles[!] [{redir}] {file} [{file} ...]                         *:FnlFiles*
  Evaluate all {file}s as one fennel expression using the fennel interpreter.

  [!] alters how the `result` is printed. Without [!] the result is printed
  with with `=>` prefix like "=> result". With it, no arrows are printed.

  {redir} applies as with |:Fnl| if specified.


:{range}FnlLines[!] [{redir}]                                      *:FnlLines*
  Evaluate {range} (default current line) as a fennel chunk.

  [!] alters how the `result` is printed. Without [!] the result is printed
  with with `=>` prefix like "=> result". With it, no arrows are printed.

  {redir} applies as with |:Fnl| if specified.


:[{range}]FnlSwiss[!] [{files}] [{redir}] [{files}] [{expr}]       *:FnlSwiss*
  This is all of the above commands merged into one
  tool: a multi-tool. Just like a Swiss army knife, it
  seems cool; but probably no one will ever need or want
  to use it.

  [!] alters how the `result` is printed.
  Without [!] the result is printed with with `=>`
  prefix like "=> result". With it, no arrows are
  printed.

  {range} can be provided like with |:FnlLines|.

  {files} can be provided like with |:FnlFiles|.
  However, each file must be `<` (and optional space)
  and can only come just before and/or after {redir}.

  {expr} can be provided like with |:Fnl|.

  If any are specified, FnlSwiss evaluates the {range}
  first, then all {files} in order, and finally any
  {expr}s.

  {redir} applies as with |:Fnl| if specified.


                                                                  *:Fnl-redir*
{redir} applies to |:Fnl|, |:FnlFile|, |:FnlLines|, and |:FnlSwiss|. It must
be specified before the {expr}. Here is a list of all redirs:

  :Fnl > {file} {expr}     (Always) Write result to {file}.
                           Note: [!] doesn't work like |:redir|
  :Fnl >> {file} {expr}    Append result to {file}

  :Fnl @{a-zA-Z}> {expr}   Save result to register {a-z}; append if {A-Z}
  :Fnl @{a-zA-Z} {expr}    Same as above (compat)
  :Fnl @{a-z}>> {expr}     Append result to register {a-z}

  :Fnl @{*+"}> {expr}      Save result to `*`, `+`, or `"` register
  :Fnl @{*+"} {expr}       Same as above (compat)
  :Fnl @{*+"}>> {expr}     Append result `*`, `+`, or `"` register
                           (See |quotestar|, |quote+|, and |quotequote|.)

  :Fnl => {var} {expr}     Save result to g:{var} (vim global variable)
  :Fnl =>> {var} {expr}    Append result to g:{var}

  The rest are not specified by |:redir| but are supported by |:Fnl|:

  :Fnl -> {var} {expr}     Save result to _G.{var} (lua global variable)
  :Fnl ->> {var} {expr}    Append result to _G.{var}

  :Fnl @_ {expr}           Disregard result (use "black hole" register)
  :Fnl == {expr}           |:put| result

Synopsis:
      Redir  Description ~
   > {file}  write `result` to file {file}
  >> {file}  append `result` to file {file}
        @+>  save `result` to register `@+` (same as @+>)
       @a>>  append `result` to register `@a` (same as @A)
   => {var}  save `result` to vim variable `g:`{var}
  =>> {var}  append `result` to vim variable `g:`{var}
   -> {var}  save `result` to lua variable `_G.`{var}
  ->> {var}  append `result` to lua variable `_G.`{var}
         @_  don't print or store `result` (black hole
         ==  |:put| result on new line

Examples: >vim
  " say hi; store "bar" into vim.g.foo
  :Fnl => foo (print "hello from fennel") "bar"
  " evaluate paragraph with fennel and put on next line commented
  :'{,'}FnlLines ==
  " evaluate ~/fennel-test.fnl into @+ register
  :FnlFiles @+> ~/fennel-test.fnl
  " eval from line to end of buffer and file ~/utils.fnl; store 9 into _G.Res
  :.,$FnlSwiss -> Res < ~/utils.fnl (sum 2 3 4)

==============================================================================
<3                                                             *elin-thanks*

A special thanks to the fennel contributors and hotpot.nvim for the hard work
necessary to make this project viable and inspiration. Thanks also to
fennel-ls and fennel-ls-nvim-docs.

https://fennel-lang.org/                              |
https://git.sr.ht/~xerool/fennel-ls                  -*-
https://github.com/rktjmp/hotpot.nvim                 |
https://dev.fennel-lang.org/wiki/WikiStart
https://git.sr.ht/~micampe/fennel-ls-nvim-docs

Thanks also to other projects that bring fennel into neovim. You all make the
fennel ecosystem a little brighter.
                                              |
https://github.com/Olical/aniseed            -*-
https://github.com/jaawerth/fennel.vim        |
https://github.com/jaawerth/fennel-nvim                            |
https://github.com/gpanders/nvim-moonwalk                         -*-
https://github.com/alexaandru/fennel-nvim                          |
https://github.com/udayvir-singh/tangerine.nvim

==============================================================================
Lore                                                             *elin-lore*

In addition to an acronym, Elin is a name that means "shining" or "brilliant".
In other words, it brings a little light from the world of lisp into neovim.

Conversely, ~evil-mode~ steals some good vim concepts and embeds them into its
dark world of ~emacs~. ;)

Pronounce the plugin name however you want! I pronounce it /ee-lin/ (like
elisp), but the name is probably pronounced /eh-lin/ :)
>
                                |
                         |     -*-
                        -*-     |
                         |                            |
  |                                                  -*-
 -*-                                                  |
  |                                           |
       |                                     -*-
      -*-                                     |                  |
       |                                                        -*-
                                                                 |
< vim:tw=78:ts=2:et:ft=help:norl:
